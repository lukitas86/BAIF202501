---
title: "Res Var"
output:
  html_document:
    df_print: paged
---

#Borro todos los datos almacenados

```{r}
rm(list = ls())
graphics.off()
```

#Cargo las librer√≠as que podr√≠a llegar a necesitar

```{r}
library (tidyverse)
#library(knitr)
#library (purrr)
library (ggplot2)
#library (tidyr)
library (quantmod)
library(flextable)
```

#Datos del ejercicio

```{r}
# Info de TSLA e NVDA
getSymbols(c("TSLA", "NVDA"), src = "yahoo", from = "2023-07-01", to = "2024-06-30")
#Importante: usar las fechas correctas

#Crear un conjunto de datos con los precios de cierre
sum(!(index(TSLA)==index(NVDA))) #chequeo que las fechas coincidan

z99 <- qnorm(0.99) # Z-score para 99% de confianza
HorVar <- sqrt(10/252)

#Para anualizar los par√°metros, utiliza la cantidad de datos que tiene su muestra
DatosAnuales <- as.numeric(nrow(TSLA))

AccionesNVDA <- 150
AccionesTSLA <- 150

stock_data <- tibble (date = index (TSLA),
                      TSLA = as.double(TSLA$TSLA.Adjusted),
                      NVDA = as.double(NVDA$NVDA.Adjusted))

PrecioTSLA <- as.numeric(tail(TSLA$TSLA.Adjusted, 1))
PrecioNVDA <- as.numeric(tail(NVDA$NVDA.Adjusted, 1))
```
#a. Esta secci√≥n calcula el valor de cada posici√≥n y la cartera total

```{r}

# Valor de cada posici√≥n
PosTSLA <- AccionesTSLA * PrecioTSLA
PosNVDA <- AccionesNVDA * PrecioNVDA
Cartera <- PosTSLA + PosNVDA

# Mostrar resultados
paste("Valor de las posiciones TSLA:", round(PosTSLA, 0),
      "- NVDA:", round(PosNVDA, 0),
      "- Cartera total:", round(Cartera, 0))

```
#Esta secci√≥n calcula las volatilidades y la correlaci√≥n de rendimientos hist√≥ricos

```{r}
# Calcular rendimientos logar√≠tmicos
RendTSLA <- log(stock_data$TSLA[2:nrow(stock_data)] / stock_data$TSLA[1:(nrow(stock_data) - 1)])
RendNVDA <- log(stock_data$NVDA[2:nrow(stock_data)] / stock_data$NVDA[1:(nrow(stock_data) - 1)])

# Guardar rendimientos en el dataset (√∫til para futuros pasos)
stock_data <- stock_data %>%
  mutate(R_TSLA = c(NA, RendTSLA),
         R_NVDA = c(NA, RendNVDA))

# Volatilidades anuales (usar 252 d√≠as h√°biles por convenci√≥n)
sigma_TSLA <- sd(RendTSLA, na.rm = TRUE) * sqrt(252)
sigma_NVDA <- sd(RendNVDA, na.rm = TRUE) * sqrt(252)

# Correlaci√≥n entre activos
Rho <- cor(RendTSLA, RendNVDA, use = "complete.obs")

# Mostrar resultados
paste("Volatilidad anual de TSLA:", round(sigma_TSLA * 100, 2), "%")
paste("Volatilidad anual de NVDA:", round(sigma_NVDA * 100, 2), "%")
paste("Correlaci√≥n hist√≥rica:", round(Rho, 4))
```
#Matriz de varianzas y covarianzas anualizadas

```{r}
VarCov <- matrix(c(
  sigma_TSLA^2, sigma_TSLA * sigma_NVDA * Rho,
  sigma_TSLA * sigma_NVDA * Rho, sigma_NVDA^2
), nrow = 2, byrow = TRUE)

colnames(VarCov) <- c("TSLA", "NVDA")
rownames(VarCov) <- c("TSLA", "NVDA")

VarCov
```

#b. C√°lculo del Var Individual

```{r}
# VaR individual monetario (para cada activo)
VaRTSLA <- PosTSLA * sigma_TSLA * HorVar * z99
VaRNVDA <- PosNVDA * sigma_NVDA * HorVar * z99

# VaR individual como porcentaje de la cartera
VaRTSLA_vs_Cartera <- VaRTSLA / Cartera
VaRNVDA_vs_Cartera <- VaRNVDA / Cartera

# Mostrar resultados
paste("VaR individual TSLA:", round(VaRTSLA, 2),
      "(", round(VaRTSLA_vs_Cartera * 100, 2), "% de la cartera )")

paste("VaR individual NVDA:", round(VaRNVDA, 2),
      "(", round(VaRNVDA_vs_Cartera * 100, 2), "% de la cartera )")
```
#c. VaR del portafolio y beneficio por diversificaci√≥n

```{r}
# NOTA: Ponderaciones de cada activo en la cartera
w_TSLA <- PosTSLA / Cartera
w_NVDA <- PosNVDA / Cartera
Pesos <- c(w_TSLA, w_NVDA)

# Calcular la varianza de la cartera con matriz de varianzas y covarianzas
VarCartera <- t(Pesos) %*% VarCov %*% Pesos %>% as.numeric()
DesvioCartera <- sqrt(VarCartera)

# VaR hist√≥rico de la cartera
VaRPortafolio <- Cartera * DesvioCartera * HorVar * z99
VaRPortafolio_vs_Cartera <- VaRPortafolio / Cartera

# Beneficio por diversificaci√≥n
BenefDiversificacion <- (VaRTSLA + VaRNVDA) - VaRPortafolio

# Mostrar resultados
paste("VaR de la cartera (hist√≥rico):", round(VaRPortafolio, 2),
      "(", round(VaRPortafolio_vs_Cartera * 100, 2), "% de la cartera )")

paste("Beneficio por diversificaci√≥n:", round(BenefDiversificacion, 2))

```
#d. VaR marginal 

```{r}
# NOTA conceptual:
# El VaR marginal mide cu√°nto aumentar√≠a el VaR total de la cartera si aumento marginalmente la posici√≥n en ese activo.
# Se basa en los betas del portafolio (sensibilidad de la cartera a cada activo).

# Recordatorio:
# VarCov = matriz de varianzas y covarianzas anualizadas
# Pesos = c(w_TSLA, w_NVDA)

# Calcular Betas (con respecto a la cartera)
Betas <- (VarCov %*% Pesos) / VarCartera

# Calcular VaR marginal para cada activo
VaRMarginales <- (VaRPortafolio / Cartera) * Betas

# Mostrar resultados
tibble(
  Activo = c("TSLA", "NVDA"),
  Beta = round(Betas, 4),
  VaR_Marginal_porcentaje = round(VaRMarginales * 100, 2)
)
```

#e. Component VaR

```{r}
# NOTA conceptual:
# El Component VaR (CVaR) indica la contribuci√≥n en d√≥lares de cada activo al VaR total del portafolio.
# Se calcula como: ponderaci√≥n en $ * VaR marginal


# Calcular Component VaR
ComponentVaR_TSLA <- VaRMarginales[1] * PosTSLA
ComponentVaR_NVDA <- VaRMarginales[2] * PosNVDA

# Verificaci√≥n de la suma (opcional)
SumaComponentVaR <- ComponentVaR_TSLA + ComponentVaR_NVDA

# Mostrar resultados
tibble(
  Activo = c("TSLA", "NVDA"),
  Component_VaR_Monetario = round(c(ComponentVaR_TSLA, ComponentVaR_NVDA), 2),
  Porcentaje_del_VaR_Total = round(c(ComponentVaR_TSLA, ComponentVaR_NVDA) / VaRPortafolio * 100, 2)
)


```

#f C√°lculo del VaR incremental al agregar 100 acciones de TSLA

```{r}
# NOTA conceptual:
# El VaR incremental mide cu√°nto aumenta el VaR del portafolio al agregar (o quitar) una posici√≥n.
# Muy √∫til para decisiones de trading o ajuste de cartera.

# Par√°metro flexible para el examen:
AccionesAdicionalesTSLA <- 100  

# NUEVAS posiciones
AccionesTSLA_Nuevo <- AccionesTSLA + AccionesAdicionalesTSLA
PosTSLA_Nuevo <- AccionesTSLA_Nuevo * PrecioTSLA
PosNVDA_Nuevo <- PosNVDA  # NVDA queda igual

# Nuevo valor de cartera
Cartera_Nueva <- PosTSLA_Nuevo + PosNVDA_Nuevo

# Nuevas ponderaciones
Pesos_Nuevos <- c(PosTSLA_Nuevo, PosNVDA_Nuevo) / Cartera_Nueva

# NUEVA varianza de la cartera (la matriz VarCov no cambia)
VarCartera_Nueva <- t(Pesos_Nuevos) %*% VarCov %*% Pesos_Nuevos %>% as.numeric()
DesvioCartera_Nuevo <- sqrt(VarCartera_Nueva)

# NUEVO VaR del portafolio con la posici√≥n adicional
VaRPortafolio_Nuevo <- Cartera_Nueva * DesvioCartera_Nuevo * HorVar * z99

# VaR incremental
VaRIncremental_TSLA <- VaRPortafolio_Nuevo - VaRPortafolio

# Mostrar resultado
paste("El VaR incremental por agregar", AccionesAdicionalesTSLA, 
      "acciones de TSLA es:", round(VaRIncremental_TSLA, 2))


```
#g. EWMA sin corregir

```{r}
# NOTA conceptual:
# EWMA aplica mayor peso a rendimientos recientes.
# Par√°metro lambda controla la memoria: m√°s alto = m√°s persistencia.

# ar√°metro que pod√©s cambiar en el examen
lambda <- 0.94  # Ajust√° seg√∫n indique el enunciado

# N√∫mero de observaciones para el c√°lculo
n <- DatosAnuales - 1  # porque son rendimientos (una fila menos)

# Calcular rendimientos logar√≠tmicos sin NAs
Rendimientos_TSLA <- stock_data$R_TSLA[-1]
Rendimientos_NVDA <- stock_data$R_NVDA[-1]

# EWMA para TSLA
aux_TSLA <- 0
for (t in 1:n) {
  aux_TSLA <- aux_TSLA + lambda^(t - 1) * Rendimientos_TSLA[n - t + 1]^2
}
Volatilidad_TSLA_EWMA_Diaria <- sqrt((1 - lambda) * aux_TSLA)
Volatilidad_TSLA_EWMA_Anual <- Volatilidad_TSLA_EWMA_Diaria * sqrt(DatosAnuales)

# EWMA para NVDA
aux_NVDA <- 0
for (t in 1:n) {
  aux_NVDA <- aux_NVDA + lambda^(t - 1) * Rendimientos_NVDA[n - t + 1]^2
}
Volatilidad_NVDA_EWMA_Diaria <- sqrt((1 - lambda) * aux_NVDA)
Volatilidad_NVDA_EWMA_Anual <- Volatilidad_NVDA_EWMA_Diaria * sqrt(DatosAnuales)

# Resultados
tibble(
  Activo = c("TSLA", "NVDA"),
  Vol_EWMA_Diaria = round(c(Volatilidad_TSLA_EWMA_Diaria, Volatilidad_NVDA_EWMA_Diaria) * 100, 2),
  Vol_EWMA_Anual = round(c(Volatilidad_TSLA_EWMA_Anual, Volatilidad_NVDA_EWMA_Anual) * 100, 2)
)

```


#h. C√°lculo de volatilidad EWMA CORREGIDO

```{r}
# NOTA conceptual:
# Incluye correcci√≥n de finitud de muestra ‚Üí insesgado

# Usamos los mismos par√°metros
n <- DatosAnuales - 1
lambda <- 0.94

# Sumatoria para la correcci√≥n
SumaPesos <- (1 - lambda^n) / (1 - lambda)

# Calcular para TSLA
aux_TSLA <- 0
for (t in 1:n) {
  aux_TSLA <- aux_TSLA + lambda^(t - 1) * Rendimientos_TSLA[n - t + 1]^2
}
Vol_TSLA_EWMA_Diaria_Corregida <- sqrt((1 - lambda) / (1 - lambda^n) * aux_TSLA)
Vol_TSLA_EWMA_Anual_Corregida <- Vol_TSLA_EWMA_Diaria_Corregida * sqrt(DatosAnuales)

# Calcular para NVDA
aux_NVDA <- 0
for (t in 1:n) {
  aux_NVDA <- aux_NVDA + lambda^(t - 1) * Rendimientos_NVDA[n - t + 1]^2
}
Vol_NVDA_EWMA_Diaria_Corregida <- sqrt((1 - lambda) / (1 - lambda^n) * aux_NVDA)
Vol_NVDA_EWMA_Anual_Corregida <- Vol_NVDA_EWMA_Diaria_Corregida * sqrt(DatosAnuales)

# Mostrar resultados
tibble(
  Activo = c("TSLA", "NVDA"),
  Vol_EWMA_Diaria_Corregida = round(c(Vol_TSLA_EWMA_Diaria_Corregida, Vol_NVDA_EWMA_Diaria_Corregida) * 100, 2),
  Vol_EWMA_Anual_Corregida = round(c(Vol_TSLA_EWMA_Anual_Corregida, Vol_NVDA_EWMA_Anual_Corregida) * 100, 2)
)

```

Concepto breve (√∫til para el examen):
El c√°lculo de la volatilidad EWMA "corregido" ajusta la f√≥rmula para garantizar que el estimador de varianza sea insesgado en muestras finitas.

Versi√≥n sin correcci√≥n: asume un n√∫mero infinito de observaciones, de modo que la suma de los pesos se aproxima a 1.

Versi√≥n corregida: normaliza por la suma real de los pesos, que es 
(1‚àíùúÜ^ùëõ) / (1 ‚àíùúÜ), para reflejar el tama√±o finito de la muestra.

¬øCu√°ndo es relevante aplicar la correcci√≥n?

Para valores de lambda muy altos (aproximadamente 0.98‚Äì0.99) y muestras cortas (50‚Äì100 datos), la diferencia puede ser significativa, llegando a varios puntos b√°sicos (aproximadamente 5‚Äì10‚ÄØ%).

Cuando se dispone de menos de aproximadamente 150‚Äì200 observaciones, en general conviene aplicar la correcci√≥n.

Para series largas, de 250 datos o m√°s, con un lambda de 0.94, la diferencia es habitualmente m√≠nima (mucho menor al 1%).

#j. Evoluci√≥n de la cartera usando proporciones actuales

```{r}
# Calcular valor actual de cada posici√≥n
PosTSLA <- AccionesTSLA * PrecioTSLA
PosNVDA <- AccionesNVDA * PrecioNVDA

# Valor total de la cartera
ValorCartera <- PosTSLA + PosNVDA

# Calcular las ponderaciones (pesos) en la cartera
PesoTSLA <- PosTSLA / ValorCartera
PesoNVDA <- PosNVDA / ValorCartera

# Vector con las proporciones actuales (calculadas previamente)
Pesos <- c(PesoTSLA, PesoNVDA)

# Crear √≠ndice ponderado con las proporciones actuales
stock_data <- stock_data %>%
  mutate(
    IndiceCartera = TSLA * Pesos[1] + NVDA * Pesos[2]
  )

# Definir el intervalo (5 d√≠as) para agrupar rendimientos
intervalo <- 5

# Obtener √≠ndices empezando desde n-1 para no perder datos recientes
IndicesUsados <- seq(nrow(stock_data) - 1, 1, by = -intervalo)

# Seleccionar filas correspondientes y ordenar por fecha ascendente
IndiceReducido <- stock_data %>%
  slice(IndicesUsados) %>%
  arrange(date)

# Calcular rendimientos logar√≠tmicos con saltos de 5 d√≠as
Rendimientos5d <- log(IndiceReducido$IndiceCartera[-1] / IndiceReducido$IndiceCartera[-nrow(IndiceReducido)])

# Calcular el valor actual de la cartera (puede estar calculado antes)
ValorCartera <- PrecioTSLA * AccionesTSLA + PrecioNVDA * AccionesNVDA

# Calcular VaR no param√©trico al 99% de confianza
VaRNoParametrico <- -quantile(Rendimientos5d, 0.01, na.rm = TRUE) * ValorCartera

# Mostrar resultado
paste0("El VaR no param√©trico (99%) con proporciones actuales es: USD ", round(VaRNoParametrico, 2))

```





