---
title: "Clase sonrisa de volatilidad"
output: html_notebook
---

#Borro todos los datos almacenados

```{r}
rm(list = ls())
graphics.off()
```

#Cargo las librerías que podría llegar a necesitar

```{r}
#library (tidyverse)
#library(knitr)
#library (purrr)
#library (ggplot2)
#library (tidyr)
library (quantmod)
#library(flextable)
```

```{r}
symbol <- "AAPL"
precios_AAPL <- getSymbols(symbol, from = "2024-01-01")
S <- 198.78
K <- 200
fecha_vto <- as.Date ("2025-06-20") #fecha de ejercicio
dia_clase <- as.Date ("2025-06-13")
t <- as.numeric (fecha_vto - dia_clase) / 365
rf <- 0.04078
q <- 0 #rendimiento del activo subyacente
tipo <- "Call"
sigma <- 0.3
prima_opcion <- 3.25 #prima negociada

```

#Definir una función para calcular el valor de la opción usando BSM

```{r}
bsm_calculadora <- function(S, K, t, rf, sigma, tipo, q) {
  d1 <- (log ( S / K ) + (rf - q + 0.5 * sigma^2) * t) / (sigma * sqrt(t))
  d2 <- d1 - sigma * sqrt(t)
  
  if (tipo == "Call") {
    option_value <- S * exp(-q * t) * pnorm(d1) - K * exp(-rf * t) * pnorm(d2)
  } else if (tipo == "Put") {
    option_value <- K * exp(-rf * t) * pnorm(-d2) - S * exp(-q * t) * pnorm(-d1)
  } else {
    stop("tipo de opción no válido. Debe ser 'Call' o 'Put'.")
  }
  
  return(option_value)
}
```

#Vega (derivada respecto a sigma)

```{r}
calculo_vega <- function(S, K, t, rf, sigma, tipo, q) {
  d1 <- (log ( S / K ) + (rf - q + 0.5 * sigma^2) * t) / (sigma * sqrt(t))
  vega <- S * exp(-q * t) * dnorm(d1) * sqrt(t)
  return(vega)
}

```


#Método de Newton-Raphson para encontrar la volatilidad implícita con rendimiento

```{r}
volatilidad_implicita <- function(S, K, t, rf, tipo, prima_opcion, q, x0, tol = 0.01, max_iter = 1000) {
  x <- x0
  iter <- 0
  
  while ((abs (bsm_calculadora (S, K, t, rf, sigma = x, tipo, q) - prima_opcion) > tol ) && iter < max_iter) {
    x <- x - (bsm_calculadora (S, K, t, rf, sigma = x, tipo, q) - prima_opcion) / calculo_vega (S, K, t, rf, sigma = x, tipo, q)
    iter <- iter+1
    
  }
  
  return(x)
}
```

#Calcular la volatilidad implícita utilizando el método de Ralph-Newton con rendimiento
```{r}


volatilidad_implicita_calculada_call <- volatilidad_implicita (S, K, t, rf, tipo, prima_opcion, q, x0 = 0.25)


paste0("La volatilidad implícita para el call es: ",
       round(volatilidad_implicita_calculada_call, 6),
       ", calculada por el método de Newton-Raphson.")
```


